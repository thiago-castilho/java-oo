====================================================================
========================= CAPÍTULO 2 ===============================
====================================================================

========================= TIPOS PRIMITIVOS =========================

boolean  // tamanho: 1 byte
byte     // tamanho: 1 byte
short    // tamanho: 2 byte
char     // tamanho: 2 byte
int      // tamanho: 4 byte
float    // tamanho: 4 byte
long     // tamanho: 8 byte
double   // tamanho: 8 byte
        


========================= TIPOS NÃO PRIMITIVOS =========================

String texto = "Eu sou uma String";
System.out.println(texto);



========================= CASTING ========================= 

Posso atriuir valores de um tipo de tamnho menor à tipos de tamanhos maiores, mas não o contrário. Por isso o casting, mas devo tomar cuidado.

    double outroLivroJava8 = 60;
    int numeroInteiro = (int) outroLivroJava8;
    System.out.println(numeroInteiro);
        
Caso o valor da váriavel seja com ponto flutuante, o numero atribuído será apenas o que está antes do ponto flutuante.

    double numeroFlutuante = 59.90;
    int recebeNumeroFlutuante = (int) numeroFlutuante;
    System.out.println(recebeNumeroFlutuante); // O número que será impresso é 59



========================= CONDICIONAIS ========================= 
Posso utilizar a condição do if na forma normal, ou em operador ternário. Não há nenhuma vantagem usar uma ou outra estratégia, e, nesse caso, o que vale é a legibilidade do código. O modo ternário deixaria o código mais complexo.
Exemplo: 
    
    NORMAL:
        double valor = 0;
        if(v1 > v2) {
            valor = 100;
        } else {
            valor = 0;
        }

    TERNÁRIO:
        double valor = v1 > v2 ? 100 : 0;




========================= LOOPINGS ========================= 
WHILE:

    while (CONDIÇÃO) {}

FOR:

    for(INICIALIZAÇÃO; CONDIÇÃO; ATUALIZAÇÃO){}

========================= OPERADOR UNÁRIO ========================= 
x++


========================= CONTINUE E BREAK ========================= 
CONTINUE:
    Usado para pular uma interação de um looping e forçar a execução do próximo laço.
    Exemplo:
        // Vai imprirmir todos os números de 0 a 10, exceto o 7 que será pulado.
        for(int i; i <= 10; i++){
            if(i == 7){
                continue;
            }
            System.out.println(i);
        }

BREAK:
    Usado para finalizar uma execução de um looping dada uma determinada condição.
    Exemplo:
        // Vai imprirmir de 0 a 6 apenas.
        for(int i; i <= 10; i++){
            if(i == 7){
                break;
            }
            System.out.println(i);
        }



========================= OPERADORES LÓGICOS ========================= 
&& (and)     - 
|| (or)      -
! (negative) - 




====================================================================
========================= CAPÍTULO 3 ===============================
====================================================================

- O paradigma de Orientação a objetos é basicamente ter bem definido a responsabilidade do que cada estado e comportamento vai ter.

- O paradigma procedural é a forma "macarrônica" de programar, onde tudo está bagunçado, comportamentos e estados com múltiplas responsabilidades, complicando muito a legibilidade do cógido.  

- Uma das vantagens da OO, é que temos uma forma forte de criar conexão entre informações e funcionalidades.




====================================================================
========================= CAPÍTULO 4 ===============================
====================================================================

========================= CÓDIGO FLEXIVEL E REAPROVEITÁVEL =========================

Deve-se sempre evitar deixar informações tão específicas em classes modelos (Livro; Autor - por exemplo), além de não sobrecarregá-los com comportamentos que não deveriam ser de sua responsabilidade.

Modificador de acesso/visibilidade "private" restring o acesso de determinado estado, deixando-o visível apenas à classe correspondente.
Quando usar um atributo com modificador "private" ? A resposta é simples: SEMPRE!Todo atributo de classe deve ser privado, assim garantimos que ninguém os acesse diretamente e viole as nossas regras de negócio.


========================= CÓDIGO ENCAPSULADO =========================

Encapsular: Nada mais do que esconder como funcionam as minhas regras de negócio, os meus métodos.

'O que esse código faz?'
'Como esse código faz?'

Como saber se meu código está bem encapsulado? É bem simples. Devo saber responder somente a primeira pergunta acima.

Valor default de cada tipo primitivo:

boolean..........................false
byte.............................0
short............................0
char............................."\u0000"
int..............................0
float............................0.0f
long.............................0l
double...........................0.0d




====================================================================
========================= CAPÍTULO 5 ===============================
====================================================================

No Java, não é possível herdar múltiplas classes. Mas é totalmente possível herdar uma classe, que herda de  uma outra. 
Vale ressaltar que esta estratégia não é muito interessante, pois aumenta e muito o acoplamento entre as classes.

Por que não usamos protected nos atributos da calsse Livro no exemplo do Ebook, que é uma classe filha? Isso porque afetaria nosso encapsulamento, e não apenas a classe filha teria acesso a esses atributos.

(super) é implementado nas classes filhas para utilizar os métodos já criados na classe pai, aproveitando o encapsulamento. Assim como construtor e etc. 

Polimorfismo: No caso dos livros (impresso e ebook) ambos são livros, mas com regras diferentes para cada. O que teriam em comum, seria que ambos devem ser adicionados no carrinho. Então, aó invés de criar dois métodos adiciona(), cada um com seu tipo (Ebook e LivroFisico), criamos apenas um com o tipo da superclasse de ambos (Livro) ficando: adiciona(Livro livro). Esse fenômeno é denominado Polimorfismo.

Herança ou composição? 
Sempre que possível, devemos favorecer a composição. O uso da herança aumenta bastante o acoplamento das classes, e de alguma forma, sempre acaba comprometendo o encapsulamento




====================================================================
========================= CAPÍTULO 6 ===============================
====================================================================

Abstract: Torna uma classe abstrata, impedindo-a de ser instanciada.

Por que a classe Livro existe se não podemos mais instanciá-la?
Porque ela idealiza tudo o que um Livro tem, e está sendo útil isolando todos os atributos e comportamentos que são um padrão entre os diferentes tipos de livro. Com isso, ela passa a servir apenas para herança e polimorfismo.

Uma observação importante: Mesmo não sendo possível instanciar uma classe abstrata, ainda podemos usá-la como referência.

Quando uma classe deve ser abstrata?
No planejamento da hieranquia e herança, veremos que algumas classes são muito específicas e que jamais deveriam ser instanciadas. Como exemplo, a classe Animal. Ela pode definir tudo o que os animais tem em comum, mas cada tipo de Animal tem suas particularidades e deve ser representado de uma forma própria.

Método abstrato: Toda classe abstrata pode ter métodos abstratos. Eles servem para obrigar suas classes filhas a implementá-los, caso contrário, o código não compilará.

Classe concreta: Classe não abstrata.

Algumas regras de uma classe abstrata:
    - Uma classe pode ser abstrata sem ter nenhum método abstrato. A partir do momento em que ela se tornar abstrata, nenhum código poderá mais instanciá-la.

    - Se você declarar um método abstrato, precisará tornar a classe abstrata também! Você não pode ter métodos abstratos em uma classe concreta (classe não abstrata).

    - Uma classe abstrata pode ter métodos abstratos e não abstratos (concretos).

    - Toda classe filha (subclasse) precisa implementar os métodos abstratos da classe pai (superclasse). A não ser que ela também seja abstrata.  
    

====================================================================
========================= CAPÍTULO 7 ===============================
====================================================================

Interface: É como um contrato Java.

Todo método sem corpo, é abstrato. Isso torna o uso da palavra "abstract" opcional na assinatura do método. O mesmo acontece ao modificador "public". Por padrão, todo método de uma interface é público.

Uma interface não pode ter atributos, e nem métodos concretos (métodos com implementação) [isso até a versão 1.7, a partir da 1.8 isso muda um pouco].

Podemos utilizar o polimorfismo com interfaces. No método adiciona() por exemplo, ao invés de colocar apenas Livros, posso colocar a interface <<Produto>> que é implementada tanto em Livro quanto em Revista.

Sempre podemos/devemos favorecer interfaces para criar polimorfismo entre as classes, o código fica muito mais flexível e com pouquíssimo acoplamento. Para inserir mais de uma interface em uma classe, utiliza-se a vírgula como separador.

INTERFACE NO JAVA 8
A partir de o java 8, uma interface agora pode ter métodos concretos (métodos com implementação), com isso, suas implementações não são obrigadas a reescrevê-lo. Esse novo recurso é conhecido como default method. Basta utilizar a palavra "default" no início da declaração do método para que ele possa ter código implementado.

INTERFACE FUNCIONAL
São as interfaces que possuem apenas um método. 
Podemos marcar uma interface funcional com a anotação @FunctionalInterface. Vale ressaltar que, caso a classe esteja com esta anotação, se adicionarmos um novo método, a classe deixará de ser compilada lançando um erro.
Um observação: Se adicionarmos métodos concretos, isso não influenciará em ela ser ou não uma interface funcional. Apenas métodos abstratos são considerados.
